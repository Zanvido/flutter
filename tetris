import 'dart:async';
import 'package:flutter/material.dart';

void main() => runApp(const TetrisApp());

class TetrisApp extends StatelessWidget {
  const TetrisApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Tetris',
      theme: ThemeData.dark().copyWith(
        scaffoldBackgroundColor: const Color(0xFF0B1020),
      ),
      home: const TetrisPage(),
    );
  }
}

class TetrisPage extends StatefulWidget {
  const TetrisPage({super.key});

  @override
  State<TetrisPage> createState() => _TetrisPageState();
}

class _TetrisPageState extends State<TetrisPage> {
  static const int boardWidth = 10;
  static const int boardHeight = 20;
  static const double cellSize = 22.0;

  late List<List<int>> board;
  Tetromino? current;
  Point currentPos = Point(3, -2);
  Timer? gravityTimer;
  bool isPaused = false;
  bool gameOver = false;
  int score = 0;
  int level = 1;
  int linesClearedTotal = 0;

  @override
  void initState() {
    super.initState();
    resetBoard();
    startNewGame();
  }

  @override
  void dispose() {
    gravityTimer?.cancel();
    super.dispose();
  }

  void resetBoard() {
    board = List.generate(boardHeight, (_) => List.filled(boardWidth, 0));
  }

  void startNewGame() {
    setState(() {
      resetBoard();
      score = 0;
      level = 1;
      linesClearedTotal = 0;
      gameOver = false;
      isPaused = false;
    });
    spawnPiece();
    startGravity();
  }

  void startGravity() {
    gravityTimer?.cancel();
    gravityTimer = Timer.periodic(Duration(milliseconds: gravityDelay()), (_) {
      if (!isPaused && !gameOver) moveDown();
    });
  }

  int gravityDelay() => (800 - (level - 1) * 60).clamp(100, 800);

  void spawnPiece() {
    final t = Tetromino.random();
    final startX = (boardWidth / 2).floor() - (t.shape[0].length / 2).floor();
    final start = Point(startX, -t.spawnOffset);
    if (checkCollision(t, start)) {
      setState(() => gameOver = true);
      gravityTimer?.cancel();
      return;
    }
    setState(() {
      current = t;
      currentPos = start;
    });
  }

  bool checkCollision(Tetromino? t, Point pos) {
    if (t == null) return true;
    for (int y = 0; y < t.shape.length; y++) {
      for (int x = 0; x < t.shape[y].length; x++) {
        if (t.shape[y][x] == 0) continue;
        final bx = pos.x + x;
        final by = pos.y + y;
        if (bx < 0 || bx >= boardWidth || by >= boardHeight) return true;
        if (by >= 0 && board[by][bx] != 0) return true;
      }
    }
    return false;
  }

  void lockPiece() {
    final t = current;
    if (t == null) return;
    for (int y = 0; y < t.shape.length; y++) {
      for (int x = 0; x < t.shape[y].length; x++) {
        if (t.shape[y][x] == 0) continue;
        final bx = currentPos.x + x;
        final by = currentPos.y + y;
        if (by >= 0 && by < boardHeight && bx >= 0 && bx < boardWidth) {
          board[by][bx] = t.id;
        }
      }
    }
    clearLines();
    spawnPiece();
  }

  void clearLines() {
    int lines = 0;
    board.removeWhere((row) {
      final full = row.every((c) => c != 0);
      if (full) lines++;
      return full;
    });
    while (board.length < boardHeight) {
      board.insert(0, List.filled(boardWidth, 0));
    }
    if (lines > 0) {
      setState(() {
        linesClearedTotal += lines;
        score += lines * 100 * level;
        if (linesClearedTotal ~/ 10 + 1 > level) level = (linesClearedTotal ~/ 10) + 1;
      });
      startGravity();
    }
  }

  void moveDown() {
    if (current == null) return;
    final newPos = Point(currentPos.x, currentPos.y + 1);
    if (checkCollision(current, newPos)) {
      lockPiece();
    } else {
      setState(() => currentPos = newPos);
    }
  }

  void moveHorizontal(int dx) {
    if (current == null) return;
    final newPos = Point(currentPos.x + dx, currentPos.y);
    if (!checkCollision(current, newPos)) setState(() => currentPos = newPos);
  }

  void rotatePiece() {
    if (current == null) return;
    final rotated = current!.rotated();
    if (!checkCollision(rotated, currentPos)) {
      setState(() => current = rotated);
    } else {
      // simple wall kick: try left/right
      if (!checkCollision(rotated, Point(currentPos.x - 1, currentPos.y))) {
        setState(() => current = rotated);
        setState(() => currentPos = Point(currentPos.x - 1, currentPos.y));
      } else if (!checkCollision(rotated, Point(currentPos.x + 1, currentPos.y))) {
        setState(() => current = rotated);
        setState(() => currentPos = Point(currentPos.x + 1, currentPos.y));
      }
    }
  }

  void hardDrop() {
    if (current == null) return;
    var p = currentPos;
    while (!checkCollision(current, Point(p.x, p.y + 1))) {
      p = Point(p.x, p.y + 1);
    }
    setState(() => currentPos = p);
    lockPiece();
  }

  void togglePause() {
    setState(() {
      isPaused = !isPaused;
    });
  }

  @override
  Widget build(BuildContext context) {
    final display = List.generate(boardHeight, (y) => List<int>.from(board[y]));
    if (current != null) {
      for (int y = 0; y < current!.shape.length; y++) {
        for (int x = 0; x < current!.shape[y].length; x++) {
          if (current!.shape[y][x] == 0) continue;
          final bx = currentPos.x + x;
          final by = currentPos.y + y;
          if (by >= 0 && by < boardHeight && bx >= 0 && bx < boardWidth) {
            display[by][bx] = current!.id;
          }
        }
      }
    }

    return Scaffold(
      appBar: AppBar(title: const Text('Tetris')),
      body: SafeArea(
        child: Center(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Container(
                    color: const Color(0xFF0F1724),
                    padding: const EdgeInsets.all(8),
                    child: Column(
                      children: [
                        SizedBox(
                          width: boardWidth * cellSize,
                          height: boardHeight * cellSize,
                          child: CustomPaint(
                            painter: BoardPainter(display, cellSize),
                          ),
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(width: 16),
                  SizedBox(
                    width: 160,
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.stretch,
                      children: [
                        Text('Score: $score', style: const TextStyle(fontSize: 20)),
                        const SizedBox(height: 8),
                        Text('Level: $level', style: const TextStyle(fontSize: 18)),
                        const SizedBox(height: 12),
                        if (gameOver)
                          Container(
                            padding: const EdgeInsets.all(8),
                            color: Colors.red.shade700,
                            child: const Center(child: Text('GAME OVER')),
                          ),
                        if (isPaused && !gameOver)
                          Container(
                            padding: const EdgeInsets.all(8),
                            color: Colors.yellow.shade700,
                            child: const Center(child: Text('PAUSED')),
                          ),
                        const SizedBox(height: 12),
                        ElevatedButton(
                          onPressed: togglePause,
                          child: Text(isPaused ? 'Resume' : 'Pause'),
                        ),
                        const SizedBox(height: 8),
                        ElevatedButton(
                          onPressed: startNewGame,
                          child: const Text('New Game'),
                        ),
                        const SizedBox(height: 16),
                        const Text('Controls', style: TextStyle(fontWeight: FontWeight.bold)),
                        const SizedBox(height: 8),
                        Wrap(
                          spacing: 8,
                          runSpacing: 8,
                          children: [
                            ElevatedButton(onPressed: () => moveHorizontal(-1), child: const Text('←')),
                            ElevatedButton(onPressed: () => moveHorizontal(1), child: const Text('→')),
                            ElevatedButton(onPressed: rotatePiece, child: const Text('Rotate')),
                            ElevatedButton(onPressed: moveDown, child: const Text('Down')),
                            ElevatedButton(onPressed: hardDrop, child: const Text('Drop')),
                          ],
                        )
                      ],
                    ),
                  )
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class BoardPainter extends CustomPainter {
  final List<List<int>> board;
  final double size;
  BoardPainter(this.board, this.size);

  static const colors = [
    Colors.transparent,
    Color(0xFF00F0F0), // I
    Color(0xFFF0F000), // O
    Color(0xFFA000F0), // T
    Color(0xFF00F000), // S
    Color(0xFFF00000), // Z
    Color(0xFF0000F0), // J
    Color(0xFFF0A000), // L
  ];

  @override
  void paint(Canvas canvas, Size canvasSize) {
    final paint = Paint();
    for (int y = 0; y < board.length; y++) {
      for (int x = 0; x < board[y].length; x++) {
        final val = board[y][x];
        final rect = Rect.fromLTWH(x * size, y * size, size - 1, size - 1);
        paint.color = colors[val.clamp(0, colors.length - 1)];
        canvas.drawRect(rect, paint);
        if (val != 0) {
          paint.color = Colors.white.withOpacity(0.06);
          canvas.drawRect(rect.deflate(2), paint);
        }
      }
    }
  }

  @override
  bool shouldRepaint(covariant BoardPainter oldDelegate) => true;
}

class Tetromino {
  final int id; // 1..7
  final List<List<int>> shape;
  final int spawnOffset;

  Tetromino(this.id, this.shape, {this.spawnOffset = 2});

  Tetromino rotated() {
    final h = shape.length;
    final w = shape[0].length;
    final List<List<int>> rotated = List.generate(w, (_) => List.filled(h, 0));
    for (int y = 0; y < h; y++) {
      for (int x = 0; x < w; x++) {
        rotated[x][h - 1 - y] = shape[y][x];
      }
    }
    return Tetromino(id, rotated, spawnOffset: spawnOffset);
  }

  static Tetromino random() {
    final list = _all;
    list.shuffle();
    return list.first;
  }

  static final List<Tetromino> _all = [
    Tetromino(1, [ [1,1,1,1] ], spawnOffset: 1), // I
    Tetromino(2, [ [2,2],[2,2] ], spawnOffset: 2), // O
    Tetromino(3, [ [0,3,0],[3,3,3] ]), // T
    Tetromino(4, [ [0,4,4],[4,4,0] ]), // S
    Tetromino(5, [ [5,5,0],[0,5,5] ]), // Z
    Tetromino(6, [ [6,0,0],[6,6,6] ]), // J
    Tetromino(7, [ [0,0,7],[7,7,7] ]), // L
  ];
}

class Point {
  final int x;
  final int y;
  const Point(this.x, this.y);
  Point copyWith({int? x, int? y}) => Point(x ?? this.x, y ?? this.y);
  @override
  String toString() => 'Point($x,$y)';
}
